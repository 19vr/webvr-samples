<!doctype html>
<!--
Copyright (c) 2016, Brandon Jones.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
-->
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <title>02 - Stereo Rendering</title>

    <!--
      This sample demonstrates how to properly render stereo views of a scene
      using the VRDisplay's eye paramaters. Nothing is presented to the
      VRDisplay.
    -->

    <style>
      #webgl-canvas {
        position: absolute;
        width: 100%;
        height: 100%;
        left: 0;
        top: 0;
        margin: 0;
      }
    </style>

    <script src="js/third-party/gl-matrix-min.js"></script>

    <script src="js/wglu/wglu-cube-sea.js"></script>
    <script src="js/wglu/wglu-program.js"></script>
    <script src="js/wglu/wglu-texture.js"></script>
    <script src="js/wglu/wglu-url.js"></script>
  </head>
  <body>
    <canvas id="webgl-canvas"></canvas>
    <script>
      "use strict";

      var vrDisplay = null;
      var projectionMat = mat4.create();
      var modelViewMat = mat4.create();

      // ===================================================
      // WebGL scene setup. This code is not WebVR specific.
      // ===================================================

      // WebGL setup.
      var webglCanvas = document.getElementById("webgl-canvas");
      var gl = webglCanvas.getContext("webgl");
      gl.clearColor(0.1, 0.2, 0.3, 1.0); // Non-black makes debugging easier.
      gl.enable(gl.DEPTH_TEST);
      gl.enable(gl.CULL_FACE);

      // Load a simple scene consisting of a grid of floating cubes.
      var textureLoader = new WGLUTextureLoader(gl);
      var texture = textureLoader.loadTexture("media/textures/cube-sea.png");
      var cubeSea = new WGLUCubeSea(gl, texture);

      function onResize() {
        webglCanvas.width = webglCanvas.offsetWidth * window.devicePixelRatio;
        webglCanvas.height = webglCanvas.offsetHeight * window.devicePixelRatio;
      }
      window.addEventListener("resize", onResize, false);
      onResize();

      // ================================
      // WebVR specific code begins here.
      // ================================

      if (navigator.getVRDisplays) {
        navigator.getVRDisplays().then(function (displays) {
          if (displays.length > 0) {
            vrDisplay = displays[0];
          }
        });
      }

      // Renders the scene from the viewpoint of the given eye and pose.
      function renderEyeView(pose, eye) {
        var orientation = pose.orientation;
        var position = pose.position;
        if (!orientation) { orientation = [0, 0, 0, 1]; }
        if (!position) { position = [0, 0, 0]; }

        // Now that we're rendering for a specific eye, we need to use the FOV
        // for that eye to generate the projection matrix. glMatrix has a
        // function specifically for this, but if you're using a different
        // library the algorithm needed is defined in the WebVR spec.
        mat4.perspectiveFromFieldOfView(projectionMat, eye.fieldOfView, 0.1, 1024.0);

        // Same matrix creation as last time, but done in an intermediate matrix
        // so that it can be multiplied by the eye offset matrix.
        mat4.fromRotationTranslation(modelViewMat, orientation, position);

        // We need to translate the view matrix by the eye's offset in order to
        // get the desired stereo effect.
        mat4.translate(modelViewMat, modelViewMat, eye.offset);

        mat4.invert(modelViewMat, modelViewMat);

        // Render the scene for this eye.
        cubeSea.render(projectionMat, modelViewMat);
      }

      function onAnimationFrame(t) {
        window.requestAnimationFrame(onAnimationFrame);
        gl.clear(gl.COLOR_BUFFER_BIT || gl.DEPTH_BUFFER_BIT);

        if (vrDisplay) {
          // When a VR display is available, render a stereo view of the scene
          // based on the diplay's pose
          var pose = vrDisplay.getPose();

          // For each eye we'll adjust the viewport to only render to half the
          // canvas, which will give us the "split screen" output that we want.

          // VRDevice.getEyeParameters gets the current parameters each eye
          // should be rendered with. These values may change from frame to
          // frame, so the best practice is to query them each time instead of
          // caching them.

          // Left eye
          gl.viewport(0, 0, webglCanvas.width * 0.5, webglCanvas.height);
          renderEyeView(pose, vrDisplay.getEyeParameters("left"));

          // Right eye
          gl.viewport(webglCanvas.width * 0.5, 0, webglCanvas.width * 0.5, webglCanvas.height);
          renderEyeView(pose, vrDisplay.getEyeParameters("right"));
        } else {
          // No VRDisplay found. Render a normal mono view to the entire canvas.
          gl.viewport(0, 0, webglCanvas.width, webglCanvas.height);
          mat4.perspective(projectionMat, 45, webglCanvas.width/webglCanvas.height, 0.1, 1024.0);
          mat4.identity(modelViewMat);
          cubeSea.render(projectionMat, modelViewMat);
        }
      }
      window.requestAnimationFrame(onAnimationFrame);
    </script>
  </body>
</html>